<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>草丁</title>
 <link href="http://leyleo.github.io/" rel="self"/>
 <link href="http://leyleo.github.io"/>
 <updated>2013-09-18T17:31:16+08:00</updated>
 <id>http://leyleo.github.io</id>
 <author>
   <name>Ley</name>
   <email>leyleo@gmail.com</email>
 </author>

 
 <entry>
   <title>Core Data Overview</title>
   <link href="http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/09/10/core-data-overview"/>
   <updated>2013-09-10T00:00:00+08:00</updated>
   <id>http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/09/10/core-data-overview</id>
   <content type="html">&lt;p&gt;写在前面：文章来自&lt;a href='http://www.objc.io/'&gt;objc.io&lt;/a&gt; &lt;a href='http://www.objc.io/issue-4/core-data-overview.html'&gt;Core Data Overview&lt;/a&gt;。作者：&lt;a href='http://twitter.com/danielboedewadt'&gt;Daniel Eggert&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;翻译的目的是为了自己加深理解，水平有限，欢迎指正。(左侧是原文，右侧是译文)&lt;/p&gt;
&lt;hr /&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Core Data is probably one of the most misunderstood Frameworks on OS X and iOS. To help with that, we’ll quickly go through Core Data to give you an overview of what it is all about, as understanding Core Data concepts is essential to using Core Data the right way. Just about all frustrations with Core Data originate in misunderstanding what it does and how it works. Let’s dive in…&lt;/td&gt;&lt;td style='text-align: left;'&gt;Core Data 大概是OS X和iOS系统上最被误解的框架之一。为了便于理解上述说法，我们将快速带你了解一下Core Data到底是什么。当然了，理解Core Data的基本概念对于正确使用它也是至关重要的。所有关于Core Data的消极看法都源自于对它的功能和工作原理的错误认识。下面就切入正题。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id='what_is_core_data'&gt;What is Core Data?&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;More than eight years ago, in April 2005, Apple released OS X version 10.4, which was the first to sport the Core Data framework. That was back when YouTube launched.&lt;/td&gt;&lt;td style='text-align: left;'&gt;八年前，也就是2005年的四月，苹果发布了OS X 10.4版本，这是Core Data框架的首次面世，也就是YouTube推出的时候。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Core Data is a model layer technology. Core Data helps you build the model layer that represents the state of your app. Core Data is also a persistent technology, in that it can persist the state of the model objects to disk. But the important takeaway is that Core Data is much more than just a framework to load and save data. It’s also about working with the data while it’s in memory.&lt;/td&gt;&lt;td style='text-align: left;'&gt;Core Data是一种数据模型层的技术。Core Data能帮你建立表示你应用状态的数据模型。Core Data也是一种持久化技术，它能够将数据模型对象的状态持久化到硬盘上。但另外非常值得注意的是，Core Data不仅仅是一个用来加载/存储数据的框架。在内存中，它仍然能够处理数据。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;If you’ve worked with &lt;a href='https://en.wikipedia.org/wiki/Object-relational_mapping'&gt;Object-relational mapping (O/RM)&lt;/a&gt; before: Core Data is not an O/RM. It’s much more. If you’ve been working with SQL wrappers before: Core Data is not an &lt;a href='https://en.wikipedia.org/wiki/Sql'&gt;SQL&lt;/a&gt; wrapper. It does by default use SQL, but again, it’s a way higher level of abstraction. If you want an O/RM or SQL wrapper, Core Data is not for you.&lt;/td&gt;&lt;td style='text-align: left;'&gt;如果你以前用过&lt;a href='https://en.wikipedia.org/wiki/Object-relational_mapping'&gt;ORM&lt;/a&gt;：Core Data不只是一种ORM，它有更多内容。如果你以前在用SQL封包：Core Data不是一种&lt;a href='https://en.wikipedia.org/wiki/Sql'&gt;SQL&lt;/a&gt;封包。它默认使用SQL实现，但它是一种更高层次上的抽象。如果你想要的是ORM或者SQL封包，Core Data不适合你。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;One of the very powerful things that Core Data provides is its object graph management. This is one of the pieces of Core Data you need to understand and learn in order to bring the powers of Core Data into play.&lt;/td&gt;&lt;td style='text-align: left;'&gt;Core Data牛掰之一就是它的数据对象图表管理。这是你能将Core Data学以致用所需要掌握的一个点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;On a side note: Core Data is entirely independent from any UI-level frameworks. It’s, by design, purely a model layer framework. And on OS X it may make a lot of sense to use it even in background daemons and the like.&lt;/td&gt;&lt;td style='text-align: left;'&gt;注释：Core Data完全独立于任何UI层级的框架。它在架构设计上属于纯粹的数据模型层框架。而且，在OS X系统上它被更多地使用，甚至用在后台守护进程或类似的地方。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id='the_stack'&gt;The Stack&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;There are quite a few components to Core Data. It’s a very flexible technology. For most uses cases, the setup will be relatively simple.&lt;/td&gt;&lt;td style='text-align: left;'&gt;Core Data有很多组件，它是一项非常灵活的技术。对大多数用例来说，它的设置相对简单。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;When all components are tied together, we refer to them as the &lt;strong&gt;&lt;em&gt;Core Data Stack&lt;/em&gt;&lt;/strong&gt;. There are two main parts to this stack. One part is about object graph management, and this should be the part that you know well, and know how to work with. The second part is about persistence, i.e. saving the state of your model objects and retrieving the state again.&lt;/td&gt;&lt;td style='text-align: left;'&gt;将Core Data各部分组件合在一起统称&lt;strong&gt;&lt;em&gt;Core Data堆栈&lt;/em&gt;&lt;/strong&gt;。主要有两部分组成：一部分关于数据对象图表管理，这部分是需要你深入掌握的，知道它的工作原理。另一部分关于持久化，例如，存储你的数据模型对象状态，及重新恢复该状态等。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;In between the two parts, in the middle of the stack, sits the Persistent Store Coordinator (PSC), also known to friends as the &lt;strong&gt;&lt;em&gt;central scrutinizer&lt;/em&gt;&lt;/strong&gt;. It ties together the object graph management part with the persistence part. When one of the two needs to talk to the other, this is coordinated by the PSC.&lt;/td&gt;&lt;td style='text-align: left;'&gt;在堆栈的两部分之间，是持久化存储协调器（Persistent Store Coordinator - PSC），俗称&lt;strong&gt;&lt;em&gt;监管中心&lt;/em&gt;&lt;/strong&gt;。它将数据对象图表管理和持久化处理两部分联系在一起。PSC负责协调两部分间的通信对话。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;img alt='Core Data Stack complex' src='http://leyleo.github.io/assets/images/201309/stack-complex.png' /&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;The object graph management is where your application’s model layer logic will live. Model layer objects live inside a context. In most setups, there’s one context and all objects live in that context. Core Data supports multiple contexts, though, for more advanced use cases. Note that contexts are distinct from one another, as we’ll see in a bit. The important thing to remember is that objects are tied to their context. Each managed object knows which context it’s in, and each context known which objects it is managing.&lt;/td&gt;&lt;td style='text-align: left;'&gt;你应用里的数据模型逻辑应该放在数据对象图表管理那部分。数据模型层的对象存在于一个context(上下文)中。在大多数的设置里，都有一个上下文，而且所有的对象都存在于这个上下文中。对于更高级的用例，Core Data也支持多上下文。需要注意的是，多个上下文相互独立，这点我们稍后再说。有一点非常重要：对象都是与它所在的上下文相关的。每个被管理的对象都知道它属于哪个上下文，每一个上下文也明白它管理哪些对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;The other part of the stack is where persistency happens, i.e. where Core Data reads and writes from / to the file system. In just about all cases, the persistent store coordinator (PSC) has one so-called persistent store attached to it, and this store interacts with a SQLite database in the file system. For more advanced setups, Core Data supports using multiple stores that are attached to the same persistent store coordinator, and there are a few store types than just SQL to choose from.&lt;/td&gt;&lt;td style='text-align: left;'&gt;堆栈的另一部分是处理持久化的，例如，Core Data对文件系统的读写操作就是在这部分完成的。绝大多数情况下，PSC都有一个所谓的持久化存储仓与之相连，而这个存储仓与文件系统中的一个SQLite数据库进行交互。对于更多需求的高级设置，Core Data支持单PSC使用多存储仓，而且除SQL以外有更多的存储类型可使用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;The most common scenario, however, looks like this:&lt;/td&gt;&lt;td style='text-align: left;'&gt;最常见的使用情况简化如下：&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;img alt='Core Data Stack simple' src='http://leyleo.github.io/assets/images/201309/stack-simple.png' /&gt;&lt;/p&gt;

&lt;h2 id='how_the_components_play_together'&gt;How the Components Play Together&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Let’s quickly walk through an example to illustrate how these components play together. In our article about a full application using Core Data, we have exactly one &lt;strong&gt;&lt;em&gt;entity&lt;/em&gt;&lt;/strong&gt;, i.e. one kind of object: We have an &lt;strong&gt;&lt;em&gt;Item&lt;/em&gt;&lt;/strong&gt; entity that holds on to a title. Each item can have sub-items, hence we have a &lt;strong&gt;&lt;em&gt;parent&lt;/em&gt;&lt;/strong&gt; and a &lt;strong&gt;&lt;em&gt;child&lt;/em&gt;&lt;/strong&gt; relationship.&lt;/td&gt;&lt;td style='text-align: left;'&gt;咱们举个栗子来说明一下这几个组件是怎么一起运转的。在文章&lt;a href=''&gt;创建一个完整Core Data应用&lt;/a&gt;中，我们恰好有一个&lt;strong&gt;&lt;em&gt;entity&lt;/em&gt;&lt;/strong&gt;（实体），也就是这么一种对象：我们有一个与title相连的&lt;strong&gt;&lt;em&gt;Item&lt;/em&gt;&lt;/strong&gt;实体，每个item项都可以有几个子项，因此就产生了&lt;strong&gt;&lt;em&gt;parent-child&lt;/em&gt;&lt;/strong&gt;这样的父子关系。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;This is our data model. As we mention in the article about Data Models and Model Objects, a particular kind of object is called an Entity in Core Data. In this case we have just one entity: an &lt;strong&gt;&lt;em&gt;Item&lt;/em&gt;&lt;/strong&gt; entity. And likewise, we have a subclass of &lt;strong&gt;NSManagedObject&lt;/strong&gt; which is called &lt;strong&gt;Item&lt;/strong&gt;. The &lt;strong&gt;&lt;em&gt;Item&lt;/em&gt;&lt;/strong&gt; entity maps to the &lt;strong&gt;Item&lt;/strong&gt; class. The data models article goes into more detail about this.&lt;/td&gt;&lt;td style='text-align: left;'&gt;这就是我们的数据模型。在&lt;a href=''&gt;数据模型与数据模型对象&lt;/a&gt;一文中我们提到，在Core Data中，我们将一类特定的对象(object)称之为实体(Entity)。在上面这个例子中，我们只有一个实体：&lt;strong&gt;&lt;em&gt;Item&lt;/em&gt;&lt;/strong&gt;. 而且，我们有一个被命名为&lt;strong&gt;Item&lt;/strong&gt;的&lt;strong&gt;NSManagedObject&lt;/strong&gt;类型子类。实体&lt;strong&gt;&lt;em&gt;Item&lt;/em&gt;&lt;/strong&gt;映射到&lt;strong&gt;Item&lt;/strong&gt;类。关于这些更详细的介绍请看&lt;a href=''&gt;数据模型与数据模型对象&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Our app has a single root item. There’s nothing magical to it. It’s simply an item we use to show the bottom of the item hierarchy. It’s an item that we’ll never set a parent on.&lt;/td&gt;&lt;td style='text-align: left;'&gt;我们的应用只有一个根部节点项。这里没啥复杂的玩意。这个根节点就是表示它处于层级关系的最低端，节点之上不会再存在任何父类节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;When the app launches, we set up our stack as depicted above, with one store, one managed object context, and a persistent store coordinator to tie the two together.&lt;/td&gt;&lt;td style='text-align: left;'&gt;当应用载入，Core Data堆栈上便有了一个存储仓，一个托管对象上下文(managed object context - MOC)，以及用来连接两部分的PSC。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;On first launch, we don’t have any items. The first thing we need to do is to create the root item. You add managed objects by inserting them into the context.&lt;/td&gt;&lt;td style='text-align: left;'&gt;应用首次载入时，不存在任何节点项。首先，我们要做的就是创建一个根节点。通过插入托管对象到上下文中来添加对应的节点。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id='creating_objects'&gt;Creating Objects&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;It may seem cumbersome. The way to insert objects is with the method on &lt;strong&gt;NSEntityDescription&lt;/strong&gt;:&lt;/td&gt;&lt;td style='text-align: left;'&gt;看起来很麻烦，添加数据对象要调用 &lt;strong&gt;NSEntityDescription&lt;/strong&gt; 的方法：&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;+ (id)insertNewObjectForEntityForName:(NSString *)entityName inManagedObjectContext:(NSManagedObjectContext *)context&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;We suggest that you add two convenience methods to your model class:&lt;/td&gt;&lt;td style='text-align: left;'&gt;我们建议你在你的模型类中添加两个方法，以便操作：&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;+ (NSString *)entityName
{
   return @“Item”;
}

+ (instancetype)insertNewObjectInManagedObjectContext:(NSManagedObjectContext *)moc
{
   return [NSEntityDescription insertNewObjectForEntityForName:[self entityName] 
                                        inManagedObjectContext:moc];
}&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Now, we can insert our root object like so:&lt;/td&gt;&lt;td style='text-align: left;'&gt;现在我们可以这样来插入根对象了：&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;Item *rootItem = [Item insertNewObjectInManagedObjectContext:managedObjectContext];&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Now there’s a single item in our managed object context (MOC). The context knows about this newly inserted managed object and the managed object &lt;strong&gt;rootItem&lt;/strong&gt; knows about the context (it has a &lt;code&gt;-managedObjectContext&lt;/code&gt; method).&lt;/td&gt;&lt;td style='text-align: left;'&gt;现在，在托管对象上下文(MOC)中存在一个对象实例了，上下文知晓这个新添加的托管对象，而且这个托管对象&lt;strong&gt;rootItem&lt;/strong&gt;也知晓所对应的上下文（托管对象有个方法叫 &lt;code&gt;-managedObjectContext&lt;/code&gt;）。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id='saving_changes'&gt;Saving Changes&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;At this point, though, we have not touched the persistent store coordinator or the persistent store, yet. The new model object, &lt;strong&gt;rootItem&lt;/strong&gt;, is just in memory. If we want to save the state of our model objects (in this case just that one object), we need to save the context:&lt;/td&gt;&lt;td style='text-align: left;'&gt;到此为止，我们还没有接触过PSC和持久化存储仓。新建的托管对象&lt;strong&gt;rootItem&lt;/strong&gt;还只存在于内存中。如果希望将数据模型对象的状态存储起来（在这个例子中只有那一个托管对象），我们需要保存对应的上下文(context):&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;NSError *error = nil;
if (! [managedObjectContext save:&amp;amp;error]) {
	// Uh, oh. An error happened. :(
}&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;At this point, a lot is going to happen. First, the managed object context figures out what has changed. It is the context’s responsibility to track any and all changes you make to any managed objects inside that context. In our case, the only change we’ve made thus far is inserting one object, our &lt;strong&gt;rootItem&lt;/strong&gt;.&lt;/td&gt;&lt;td style='text-align: left;'&gt;现在开始有很多事被触发。首先，MOC判断哪些数据发生了修改。对应的上下文负责跟踪所有属于该上下文内的托管对象的任何修改。在我们的例子中，我们到目前为止唯一做的修改就是插入一个&lt;strong&gt;rootItem&lt;/strong&gt;对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;The managed object context then passes these changes on to the persistent store coordinator and asks it to propagate the changes through to the store. The persistent store coordinator coordinates with the store (in our case, an SQL store) to write our inserted object into the SQL database on disk. The &lt;strong&gt;NSPersistentStore&lt;/strong&gt; class manages the actual interaction with SQLite and generates the SQL code that needs to be executed. The persistent store coordinator’s role is to simply coordinate the interaction between the store and the context. In our case, that role is relatively simple, but complex setups can have multiple stores and multiple contexts.&lt;/td&gt;&lt;td style='text-align: left;'&gt;MOC将这些修改传给PSC，并让PSC传给存储仓。PSC配合存储仓（在我们的例子中，是SQL存储仓）将我们插入的对象写入硬盘的SQL数据库中。&lt;strong&gt;NSPersistentStore&lt;/strong&gt; 类管理与SQLite的实际交互，并生成需要被执行的SQL代码。PSC的角色就是简单协调存储仓和上下文之间的交互。本例中，PSC工作相当少，但是通过复杂的配置可以协调多个存储仓和多个上下文。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id='updating_relationships'&gt;Updating Relationships&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;The power of Core Data is managing relationships. Let’s look at the simple case of adding our second item and making it a child item of the &lt;strong&gt;rootItem&lt;/strong&gt;:&lt;/td&gt;&lt;td style='text-align: left;'&gt;Core Data的强大之处在于管理数据关系。我们来看一个简单的例子，将第二个数据项添加进来，并将其作为&lt;strong&gt;rootItem&lt;/strong&gt;的子项：&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;Item *item = [Item insertNewObjectInManagedObjectContext:managedObjectContext];
item.parent = rootItem;
item.title = @&amp;quot;foo&amp;quot;;&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;That’s it. Again, these changes are only inside the managed object context. Once we save the context, however, the managed object context will tell the persistent store coordinator to add that newly created object to the database file just like for our first object. But it will also update the relationship from our second item to the first and the other way around, from the first object to the second. Remember how the &lt;strong&gt;&lt;em&gt;Item&lt;/em&gt;&lt;/strong&gt; entity has a parent and a children relationship. These are reverse relationships of one another. Because we set the first item to be the parent of the second, the second will be a child of the first. The managed object context tracks these relationships and the persistent store coordinator and the store persist (i.e. save) these relationships to disk.&lt;/td&gt;&lt;td style='text-align: left;'&gt;搞定。同样的，这次的修改仅仅是插入数据到MOC。一旦我们保存了context，MOC就会告诉PSC将新建的数据对象添加到数据库文件去，就像第一个对象的操作那样。不过它还会更新从第二个数据项到第一个数据项的数据关系，及从第一个到第二个数据项的数据关系。记得搞清&lt;strong&gt;&lt;em&gt;Item&lt;/em&gt;&lt;/strong&gt;实体的父子关系，另一个实体要逆向。因为我们将第一项设置为第二项的父节点，第二项就是第一项的子节点。MOC跟踪这些数据关系，PSC和存储仓将这些数据关系持久化（例如，save）到硬盘上。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id='getting_to_objects'&gt;Getting to Objects&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Let’s say we’ve been using our app for a while and have added a few sub-items to the root item, and even sub-items to the sub-items. Then we launch our app again. Core Data has saved the relationships of the items in the database file. The object graph is persisted. We now need to get to our root item, so we can show the bottom-level list of items. There are two ways for us to do that. We’ll look at the simpler one first.&lt;/td&gt;&lt;td style='text-align: left;'&gt;假设我们用了我们的应用一阵子，并添加了一些子数据项到根数据项上，甚至在子项的里面添加了一些子项。然后重新加载我们的应用。Core Data把这些数据项的数据关系在数据库文件里存的好好的。对象图表也存的妥妥的。现在我们需要取出根节点的内容，因此我们先列出来位于最底层级的元素。我们有两种方法来实现，先看第一种比较简单的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;When we created our &lt;strong&gt;rootItem&lt;/strong&gt; object, and once we’ve saved it, we can ask it for its &lt;strong&gt;NSManagedObjectID&lt;/strong&gt;. This is an opaque object that uniquely represents that object. We can store this into e.g. &lt;strong&gt;NSUserDefaults&lt;/strong&gt;, like this:&lt;/td&gt;&lt;td style='text-align: left;'&gt;当我们创建了&lt;strong&gt;rootItem&lt;/strong&gt;对象，而且保存了它，我们就可以通过它的&lt;strong&gt;NSManagedObjectID&lt;/strong&gt;查找到。这是用以代表该实体对象唯一性的对象类。我们能将其存储到诸如&lt;strong&gt;NSUserDefaults&lt;/strong&gt;之类的地方，如下：&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
[defaults setURL:rootItem.managedObjectID.URIRepresentation forKey:@&amp;quot;rootItem&amp;quot;];&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when the app is relaunched, we can get back to the object like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
NSURL *uri = [defaults URLForKey:@&amp;quot;rootItem&amp;quot;];
NSManagedObjectID *moid = [managedObjectContext.persistentStoreCoordinator managedObjectIDForURIRepresentation:uri];
NSError *error = nil;
Item *rootItem = (id) [managedObjectContext existingObjectWithID:moid error:&amp;amp;error];&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Obviously, in a real app, we’d have to check if &lt;strong&gt;NSUserDefaults&lt;/strong&gt; actually returns a valid value.&lt;/td&gt;&lt;td style='text-align: left;'&gt;显而易见的是，在实际的应用里，我们最好确认&lt;strong&gt;NSUserDefaults&lt;/strong&gt;返回的是有效值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;What just happened is that the managed object context asked the persistent store coordinator to get that particular object from the database. The root object is now back inside the context. However, all the other items are not in memory, yet.&lt;/td&gt;&lt;td style='text-align: left;'&gt;刚才那段讲的是MOC向PSC请求从数据库中取出那个指定的数据对象。那个根数据对象便恢复到context上下文中。不过其他的数据项并没有在内存中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;The &lt;strong&gt;rootItem&lt;/strong&gt; has a relationship called children. But there’s nothing there, yet. We want to display the sub-items of our &lt;strong&gt;rootItem&lt;/strong&gt;, and hence we’ll call:&lt;/td&gt;&lt;td style='text-align: left;'&gt;&lt;strong&gt;rootItem&lt;/strong&gt;有一个指向子项的数据关系。不过到现在为止还没有载入，我们希望显示&lt;strong&gt;rootItem&lt;/strong&gt;的所有子项，因此我们调用：&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;NSOrderedSet *children = rootItem.children;&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;What happens now, is that the context notes that the relationship children from that &lt;strong&gt;rootItem&lt;/strong&gt; is a so-called fault. Core Data has marked the relationship as something it still has to resolve. And since we’re accessing it at this point, the context will now automatically coordinate with the persistent store coordinator to bring those child items into the context.&lt;/td&gt;&lt;td style='text-align: left;'&gt;这时context上下文发现从&lt;strong&gt;rootItem&lt;/strong&gt;到子项的数据关系还是个所谓的假象，Core Data所标识的数据关系需要被进一步处理。在我们调用了这个getter后，context上下文开始自动地由PSC协同处理将那些子项载入到该context中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;This may sound very trivial, but there’s actually a lot going on at this point. If any of the child objects happen to already be in memory, Core Data guarantees that it will reuse those objects. That’s what is called &lt;strong&gt;&lt;em&gt;uniquing&lt;/em&gt;&lt;/strong&gt;. Inside the context, there’s never going to be more than a single object representing a given item.&lt;/td&gt;&lt;td style='text-align: left;'&gt;看起来很小的一点儿操作，其实执行了很多操作。如果那些子对象中的一个或几个碰巧已经在内存中了，Core Data就重用已在内存中的对象。这种做法被称作&lt;strong&gt;&lt;em&gt;uniquing&lt;/em&gt;&lt;/strong&gt;。在context中，不会出现多个对象表示一个已存在项的情况。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Secondly, the persistent store coordinator has its own internal cache of object values. If the context needs a particular object (e.g. a child item), and the persistent store coordinator already has the needed values in its cache, the object (i.e. the item) can be added to the context without talking to the store. That’s important, because accessing the store means running SQL code, which is much slower than using values already in memory.&lt;/td&gt;&lt;td style='text-align: left;'&gt;另外一点，PSC在其内部对数据对象的值进行了缓存（cache）。如果context上下文需要取某个对象（例如，一个子项），而这个对象的值已经在PSC的缓存中，那么该对象（即上面的子项）将直接被添加到context上下文中，不需要再向存储仓发起请求。这点非常重要，因为请求存储仓意味着要运行SQL语句，这与直接使用内存中的值相比要花费更长的时间。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;As we continue to traverse from item to sub-item to sub-item, we’re slowly bringing the entire object graph into the managed object context. Once it’s all in memory, operating on objects and traversing the relationships is super fast, since we’re just working inside the managed object context. We don’t need to talk to the persistent store coordinator at all. Accessing the &lt;strong&gt;title&lt;/strong&gt;, &lt;strong&gt;parent&lt;/strong&gt;, and &lt;strong&gt;children&lt;/strong&gt; properties on our &lt;strong&gt;Item&lt;/strong&gt; objects is super fast and efficient at this point.&lt;/td&gt;&lt;td style='text-align: left;'&gt;我们从一个数据项访问到它的子项，接着到子项的子项，就这样逐渐地将整个对象图表加载到MOC中。一旦全都加载到内存中，对对象的操作和对数据关系的遍历就变得特别快速，因为我们只需要在MOC内部操作，而不需要对PSC进行通信。这样一来，对&lt;strong&gt;Item&lt;/strong&gt;那些&lt;strong&gt;title&lt;/strong&gt;,&lt;strong&gt;parent&lt;/strong&gt;,&lt;strong&gt;children&lt;/strong&gt;等属性的读取就变得非常快，效率也提高了很多。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;It’s important to understand how data is fetched in these cases, since it affects performance. In our particular case, it doesn’t matter too much, since we’re not touching a lot of data. But as soon as you do, you’ll need to understand what goes on under the hood.&lt;/td&gt;&lt;td style='text-align: left;'&gt;了解数据读取的原理是非常重要的，因为它影响到应用的性能。在我们的这个例子里，由于并没有接触大量的数据，所以影响不大。但是你要尽早理解它的内部原理。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;When you traverse a relationship (such as parent or children in our case) one of three things can happen: (1) the object is already in the context and traversing is basically for free. (2) The object is not in the context, but the persistent store coordinator has its values cached, because you’ve recently retrieved the object from the store. This is reasonably cheap (some locking has to occur, though). The expensive case is (3) when the object is accessed for the first time by both the context and the persistent store coordinator, such that is has to be retrieved by store from the SQLite database. This last case is much more expensive than (1) and (2).&lt;/td&gt;&lt;td style='text-align: left;'&gt;当你遍历一个数据关系时（像咱们例子里的父子关系），会发生下面三种情况中的一种：(1) 待遍历的对象已经在context上下文中，可以轻松自由地遍历。（2）待遍历的对象不在context中，但是PSC已经将它的值缓存进来了，这通常发生在你刚才已经在数据仓中检索过这个对象的时候，这种情况对性能的影响还算可以（不过，还是会有些卡顿）。造价最高的情况是（3）待遍历的对象是第一次被context上下文和PSC检索，这时候必不可少地从数据仓中将SQLite数据库里的内容取出。第三种情况比（1）和（2）更耗费资源。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;If you know you have to fetch objects from the store (because you don’t have them), it makes a huge difference when you can limit the number of fetches by getting multiple objects at once. In our example, we might want to fetch all child items in one go instead of one-by-one. This can be done by crafting a special &lt;strong&gt;NSFetchRequest&lt;/strong&gt;. But we must take care to only to run a fetch request when we need to, because a fetch request will also cause option (3) to happen; it will always access the SQLite database. Hence, when performance matters, it makes sense to check if objects are already around. You can use &lt;code&gt;-[NSManagedObjectContext objectRegisteredForID:]&lt;/code&gt; for that.&lt;/td&gt;&lt;td style='text-align: left;'&gt;如果你预先知道你要从数据仓里读取很多数据对象出来（因为他们一开始不会在内存中），那么通过一次读取多个数据来降低读取的次数，可以提升很多性能。在我们的例子里，我们如果想读取所有的子项出来，一次读取所有要比一次取一项要好。这种操作可以通过执行特定的&lt;strong&gt;NSFetchRequest&lt;/strong&gt;来完成。不过我们必须要小心在必要的时候只使用一条读取请求（fetch request），因为一条读取请求也会引发上面的情况（3）发生；它总是会请求SQLite数据库。因此，当有性能问题时，需要格外注意所用的对象是不是已经在内存中了。你可以通过 &lt;code&gt;-[NSManagedObjectContext objectRegisteredForID:]&lt;/code&gt; 来判断。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id='changing_object_values'&gt;Changing Object Values&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Now, let’s say we are changing the &lt;strong&gt;title&lt;/strong&gt; of one of our &lt;strong&gt;Item&lt;/strong&gt; objects:&lt;/td&gt;&lt;td style='text-align: left;'&gt;现在，我们来改变一个&lt;strong&gt;Item&lt;/strong&gt;数据对象的&lt;strong&gt;title&lt;/strong&gt;值：&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;item.title = @&amp;quot;New title&amp;quot;;&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;When we do this, the items &lt;strong&gt;title&lt;/strong&gt; changes. But additionally, the managed object context marks the specific managed object (item) as changed, such that it will be saved through the persistent store coordinator and attached store when we call -save: on the context. One of the key responsibilities of the context is &lt;strong&gt;&lt;em&gt;change tracking&lt;/em&gt;&lt;/strong&gt;.&lt;/td&gt;&lt;td style='text-align: left;'&gt;我们执行了上面操作后，这项数据的&lt;strong&gt;title&lt;/strong&gt;值发生了改变。另外，MOC将这个托管数据对象（item）标示为已修改（changed），这样当我们在context上下文中执行&lt;code&gt;-save:&lt;/code&gt;时，所做的修改将通过PSC被保存到相关联的数据仓中。context上下文的一个关键任务就是&lt;strong&gt;&lt;em&gt;状态跟踪&lt;/em&gt;&lt;/strong&gt;（change tracking）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;The context knows which objects have been inserted, changed, and deleted since the last save. You can get to those with the &lt;code&gt;-insertedObjects&lt;/code&gt;, &lt;code&gt;-updatedObjects&lt;/code&gt;, and &lt;code&gt;-deletedObjects&lt;/code&gt; methods. Likewise, you can ask a managed object which of its values have changed by using the -changedValues method. You will probably never have to. But this is what Core Data uses to be able to push changes you make to the backing database.&lt;/td&gt;&lt;td style='text-align: left;'&gt;context上下文知道从上次保存以来都有哪些数据对象被插入，修改，和删除。你可以通过&lt;code&gt;-insertedObjects&lt;/code&gt;, &lt;code&gt;-updatedObjects&lt;/code&gt;, &lt;code&gt;-deletedObjects&lt;/code&gt;方法分别得到对应的数据项。类似，你可以通过&lt;code&gt;-changedValues&lt;/code&gt;方法得到托管数据对象中有哪些参数值发生了改变。或许这些方法你永远也用不着。不过这就是Core Data用来向后端的数据库所发送的修改信息。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;When we inserted new &lt;strong&gt;Item&lt;/strong&gt; objects above, this is how Core Data knew it had to push those to the store. And now, when we changed the &lt;strong&gt;title&lt;/strong&gt;, the same thing happened.&lt;/td&gt;&lt;td style='text-align: left;'&gt;当我们在上面讲到插入新的&lt;strong&gt;Item&lt;/strong&gt;数据对象时，知道了Core Data是怎么知道它得向数据仓推送数据的。当我们修改了&lt;strong&gt;title&lt;/strong&gt;时，逻辑类似。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Saving values needs to coordinate with both the persistent store coordinator and the persistent store, which, in turn, accesses the SQLite database. As when retrieving objects and values, accessing the store and database is relatively expensive when compared to simply operating on objects in memory. There’s a fixed cost for a save, regardless of how many changes you’re saving. And there’s a per-change cost. This is simply how SQLite works. When you’re changing a lot of things, you should therefore try to batch changes into reasonably sized batches. If you save for each change, you’d pay a high price, because you have to save very often. If you save to rarely, you’d have a huge batch of changes that SQLite would have to process.&lt;/td&gt;&lt;td style='text-align: left;'&gt;保存数据值需要PSC和持久化的数据仓相配合来访问SQLite数据库。从数据仓（store）和数据库(database)中检索数据对象和参数值要比在内存中检索耗费更多的性能。执行一次保存所消费的性能是固定的，跟你要保存多少项修改无关。另外有一种消费的性能是不定的，跟SQLite的执行能力相关。当你要修改很多数据时，最好尝试将一批修改分割为适当固定大小的批块。如果每次修改都分别进行保存，将会耗费你大量的性能，因为你要经常执行保存操作。如果你存储间隔太长，到最后SQLite需要处理大批量的修改。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;It is also important to note that saves are atomic. They’re transactional. Either all changes will be committed to the store / SQLite database or none of the changes will be saved. This is important to keep in mind when implementing custom &lt;strong&gt;NSIncrementalStore&lt;/strong&gt; subclasses. You have to either guarantee that a save will never fail (e.g. due to conflicts), or your store subclass has to revert all changes when the save fails. Otherwise, the object graph in memory will end up being inconsistent with the one in the store.&lt;/td&gt;&lt;td style='text-align: left;'&gt;另外需要注意的是，每次保存都是原子性(atomic)的，不可分割的，每次提交到存储仓/SQLite数据库中的修改要么全都被保存了，要么就一个也没存上。如果你要自己扩展&lt;strong&gt;NSIncrementalStore&lt;/strong&gt;的子类时尤其需要注意这点。你要保证一次的保存中，所有的修改都没出错（譬如由于冲突导致的错误），或者你的子类在遇到保存失败时，需要将这次的所有修改恢复到保存前的状态。不然的话，在内存中的数据对象图表和数据仓里的图表就不一致了。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Saves will normally never fail if you use a simple setup. But Core Data allows multiple contexts per persistent store coordinator, so you can run into conflicts at the persistent store coordinator level. Changes are per-context, and another context may have introduced conflicting changes. And Core Data even allows for completely separate stacks both accessing the same SQLite database file on disk. That can obviously also lead to conflicts (i.e. one context trying to update a value on an object that was deleted by another context). Another reason why a save can fail is validation. Core Data supports complex validation policies for objects. It’s an advanced topic. A simple validation rule could be that the &lt;strong&gt;title&lt;/strong&gt; of an &lt;strong&gt;Item&lt;/strong&gt; must not be longer than 300 characters. But Core Data also supports complex validation policies across properties.&lt;/td&gt;&lt;td style='text-align: left;'&gt;如果你设置简单的话，保存的操作通常不会失败。但是Core Data允许单PSC有多context上下文，所以在PSC阶段会存在数据冲突现象。修改是在每一个context中进行的，一个context中的修改可能会跟另一处的修改发生冲突。而且Core Data甚至允许两个独立的数据堆栈（stack）都对硬盘上的同一个SQLite数据库进行读取。显然也会引起数据冲突（例如，一个context试图更新某个数据对象，而另一个context已经将该数据对象删除了）。另外一个会导致保存失败的原因是数据有效性。暂且不表。Core Data支持数据对象的复杂有效性检查。一个简单的有效性规则应该是&lt;strong&gt;Item&lt;/strong&gt;对象的&lt;strong&gt;title&lt;/strong&gt;不能超过300字符，不过Core Data也支持跨属性间的复杂有效性检查。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id='final_words'&gt;Final Words&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;If Core Data seems daunting, that’s most likely because its flexibility allows you to use it in very complex ways. As always: try to keep things as simple as possible. It will make development easier and save you and your user from trouble. Only use the more complex things such as background contexts if you’re certain they will actually help.&lt;/td&gt;&lt;td style='text-align: left;'&gt;如果说Core Data令人怯步，那很有可能是因为它的灵活性让你能操作各种复杂的情况。一如既往地是：让事情尽可能地保持简单。它能使开发变得更轻松，让你和你的用户避免麻烦。在你确信使用诸如后台上下文（background context）等复杂设置的确对你有用时，再使用这些。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;When you’re using a simple Core Data stack, and you use managed objects the way we’ve tried to outline in this issue, you’ll quickly learn to appreciate what Core Data can do for you, and how it speeds up your development cycle.&lt;/td&gt;&lt;td style='text-align: left;'&gt;如果你使用简化的Core Data堆栈方式，并按照本文中所讲述的方法使用托管对象（managed object）时，你很快就会感谢Core Data所为你提供的一切，感谢它为你缩短了不少的开发周期。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr /&gt;
&lt;p&gt;该系列更多文章，请见：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/09/10/core-data/'&gt;Editorial&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-4/full-core-data-application.html'&gt;A Complete Core Data Application&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-4/SQLite-instead-of-core-data.html'&gt;On Using SQLite and FMDB Instead of Core Data&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-4/core-data-models-and-model-objects.html'&gt;Data Models and Model Objects&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-4/importing-large-data-sets-into-core-data.html'&gt;Importing Large Data Sets&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-4/core-data-fetch-requests.html'&gt;Fetch Requests&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-4/core-data-migration.html'&gt;Custom Core Data migrations&lt;/a&gt; 待译&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>Core Data</title>
   <link href="http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/09/10/core-data"/>
   <updated>2013-09-10T00:00:00+08:00</updated>
   <id>http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/09/10/core-data</id>
   <content type="html">&lt;p&gt;写在前面：这一系列文章来自&lt;a href='http://www.objc.io/'&gt;objc.io&lt;/a&gt; &lt;a href='http://www.objc.io/issue-4/editorial.html'&gt;issue-4&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;翻译的目的是为了自己加深理解，水平有限，欢迎指正。(左侧是原文，右侧是译文)&lt;/p&gt;
&lt;hr /&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;The &lt;a href=''&gt;(1) fourth issue&lt;/a&gt; of objc.io is all about Core Data, starting with Daniel’s &lt;a href=''&gt;(2) Core Data Overview&lt;/a&gt; and Chris’s tutorial for building a &lt;a href=''&gt;(3) simple but complete Core Data application&lt;/a&gt;. Next, before we go into more specifics, enjoy Brent’s piece on how he &lt;a href=''&gt;(4) uses SQLite instead of Core Data&lt;/a&gt; and why you probably shouldn’t. Then you can sink your teeth into in-depth technical articles about &lt;a href=''&gt;(5) data models and model objects&lt;/a&gt; and &lt;a href=''&gt;(6) importing large data sets&lt;/a&gt; by Florian, &lt;a href=''&gt;(7) performant fetching&lt;/a&gt; by Daniel, and &lt;a href=''&gt;(8) custom Core Data migrations&lt;/a&gt; by Martin.&lt;/td&gt;&lt;td style='text-align: left;'&gt;objc.io的&lt;a href=''&gt;(1)第四个话题&lt;/a&gt;是关于Core Data的，开篇先是来自Daniel的&lt;a href=''&gt;(2)Core Data概览&lt;/a&gt;，和来自Chris的教程：&lt;a href=''&gt;(3)创建一个深入浅出的Core Data应用&lt;/a&gt;。在我们更深入细节之前，请先品味下Brent的文章，文章讲述了他是怎么&lt;a href=''&gt;(4)用SQLite来替代Core Data&lt;/a&gt;，思考下为什么你几乎不会采用。接下来，你就可以专心致志地研磨这些进阶文章了：来自Florian的&lt;a href=''&gt;(5)数据模型和数据对象&lt;/a&gt;及&lt;a href=''&gt;(6)引入大型数据集合&lt;/a&gt;，来自Daniel的&lt;a href=''&gt;(7)提升查取性能&lt;/a&gt;，来自Martin的&lt;a href=''&gt;(8)自定义Core Data迁移&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id='id2'&gt;导论&lt;/h2&gt;

&lt;p&gt;September 2013&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Welcome to objc.io issue #4!&lt;/td&gt;&lt;td style='text-align: left;'&gt;欢迎来到objc.io话题四！&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;In this issue we are taking an in-depth look into Apple’s model layer framework, Core Data.&lt;/td&gt;&lt;td style='text-align: left;'&gt;在这个话题中，我们将深入学习苹果的数据模型层框架，Core Data.&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Core Data is a powerful object graph management and persistence framework, which has been available on both iOS and OS X for many years. Nevertheless, even experienced developers often don’t use it. Additionally, there is a lot of misleading information about Core Data on the Internet, which can confuse newcomers.&lt;/td&gt;&lt;td style='text-align: left;'&gt;Core Data是一个非常强大的图形化数据管理及持久化框架，在iOS和OS X系统上已经使用多年了。然而，即便是经验丰富的开发者也很少用它。另外，网上有很多关于Core Data的误解，会让新手感到迷惑。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;The articles in this issue provide a deeper overview of what Core Data is, how it works, and how you should use it. If you haven’t worked with Core Data before, you will find the &lt;a href=''&gt;overview&lt;/a&gt; and the example of building a &lt;a href=''&gt;full Core Data application&lt;/a&gt; useful. If you’re familiar with Core Data, we have several articles which cover the topics of &lt;a href=''&gt;managed objects&lt;/a&gt;, &lt;a href=''&gt;fetching data&lt;/a&gt;, &lt;a href=''&gt;importing large data sets&lt;/a&gt;, and &lt;a href=''&gt;migrations&lt;/a&gt; (the latter is thanks to our guest writer Martin Hwasser).&lt;/td&gt;&lt;td style='text-align: left;'&gt;该话题的一系列文章深入地介绍了关于Core Data的情况，包括：Core Data是什么，它的原理是什么，你该如何使用它。如果你之前没有接触过Core Data，你在看完&lt;a href=''&gt;概览&lt;/a&gt;，并跟着例子&lt;a href=''&gt;创建一个完整Core Data应用&lt;/a&gt;后就会明白了。如果你已经熟知Core Data，那么我们提供有若干的文章，覆盖从&lt;a href=''&gt;数据模型管理&lt;/a&gt;，&lt;a href=''&gt;数据查取&lt;/a&gt;，&lt;a href=''&gt;大型数据集合引入&lt;/a&gt;，到&lt;a href=''&gt;数据库迁移&lt;/a&gt;(特此感谢我们的客座作者Martin Hwasser)等话题。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Last but not least, special guest writer &lt;a href='http://inessential.com/'&gt;Brent Simmons&lt;/a&gt; gives you an overview of how he uses SQLite directly in his applications, including the recently released &lt;a href='http://vesperapp.co/'&gt;Vesper&lt;/a&gt;, but why you probably shouldn’t. It’s an interesting peek behind the scenes that shows what it takes to manually recreate what Core Data does for us.&lt;/td&gt;&lt;td style='text-align: left;'&gt;最后，特邀作者&lt;a href='http://inessential.com/'&gt;Brent Simmonm&lt;/a&gt;概述了他是如何在他的若干个应用中直接使用SQLite数据库（包括最近发布的&lt;a href='http://vesperapp.co/'&gt;Vesper&lt;/a&gt;），也说到了为什么你或许不应该这么做。这是一篇有意思的文章，它向我们展示了自己动手如何实现那些Core Data提供给我们的服务。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;We wish you a successful iOS 7 launch month!&lt;/td&gt;&lt;td style='text-align: left;'&gt;We wish you a successful iOS 7 launch month!&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;All the best from Berlin,&lt;/td&gt;&lt;td style='text-align: left;'&gt;All the best from Berlin,&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Chris, Daniel &amp;amp; Florian.&lt;/td&gt;&lt;td style='text-align: left;'&gt;Chris, Daniel &amp;amp; Florian.&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr /&gt;
&lt;p&gt;该系列更多文章，请见：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/09/10/core-data-overview/'&gt;Core Data Overview&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-4/full-core-data-application.html'&gt;A Complete Core Data Application&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-4/SQLite-instead-of-core-data.html'&gt;On Using SQLite and FMDB Instead of Core Data&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-4/core-data-models-and-model-objects.html'&gt;Data Models and Model Objects&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-4/importing-large-data-sets-into-core-data.html'&gt;Importing Large Data Sets&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-4/core-data-fetch-requests.html'&gt;Fetch Requests&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-4/core-data-migration.html'&gt;Custom Core Data migrations&lt;/a&gt; 待译&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>用Android模拟器运行OpenGL</title>
   <link href="http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/09/06/android-emulator-for-opengl"/>
   <updated>2013-09-06T00:00:00+08:00</updated>
   <id>http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/09/06/android-emulator-for-opengl</id>
   <content type="html">&lt;p&gt;写在前面：这篇文章是在用cocos2d-x JSB开发游戏时从官方找到的文档，网上没有找到比这个好用的完整解决方法了。以后有时间会翻译成中文。&lt;/p&gt;

&lt;h3 id='problem_and_solution'&gt;Problem and solution&lt;/h3&gt;

&lt;p&gt;For a few years the only option was to run the Android emulator by emulating the ARM instruction set on a x86 host machine. While this is still possible, it has two problems&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;it is very, very slow&lt;/li&gt;

&lt;li&gt;GPU support and OpenGL ES 2.0 is not well supported&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So cocos2d-x does not run correctly.&lt;/p&gt;

&lt;p&gt;The fix is to use virtualization with the x86 version of Android and enable GPU acceleration. With these options enabled, you can successfully use the emulator to develop with cocos2d-x!&lt;/p&gt;

&lt;h3 id='howto'&gt;How-to&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Download and create an Android emulator using the x86 system image&lt;/li&gt;

&lt;li&gt;Enable virtualization (with CPU&amp;#8217;s that support VT-X) on Windows/Linux/OSX&lt;/li&gt;

&lt;li&gt;Build cocos2d-x libraries for the x86 architecture too&lt;/li&gt;

&lt;li&gt;Run the emulator with the correct library path and options&lt;/li&gt;

&lt;li&gt;Success!&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id='download_and_create_an_android_emulator_using_the_x86_system_image'&gt;Download and create an Android emulator using the x86 system image&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Run the android emulator manager :&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;
&amp;lt;android-sdk&amp;gt;/tools/android
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Ensure that &amp;#8220;Intel x86 Atom System Image&amp;#8221; is selected, downloaded and installed for the Android version you are using.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Open the menu item&lt;/p&gt;

&lt;p&gt;&amp;#8220;Tools&amp;#8221;-&amp;gt;&amp;#8221;Manage AVDs&amp;#8221;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Create a new Android Virtual Device&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Make sure to select the &amp;#8220;x86&amp;#8221; option in the CPU/ABI dropdown&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Make sure to select the &amp;#8220;Use Host GPU&amp;#8221; checkbox&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id='enable_virtualization_with_cpus_that_support_vtx_on_windowslinuxosx'&gt;Enable virtualization (with CPU&amp;#8217;s that support VT-X) on Windows/Linux/OSX&lt;/h4&gt;

&lt;p&gt;Please follow intel&amp;#8217;s instructions here on downloading/enabling virtualization for the Android emulator http://software.intel.com/en-us/articles/intel-hardware-accelerated-execution-manager/&lt;/p&gt;

&lt;h4 id='build_cocos2dx_libraries_for_the_x86_architecture_too'&gt;Build cocos2d-x libraries for the x86 architecture too&lt;/h4&gt;

&lt;p&gt;In your app&amp;#8217;s Application.mk, add x86 to the supported ABI&amp;#8217;s by adding/editing this line&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
APP_ABI := armeabi x86
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id='run_the_emulator_with_the_correct_library_path_and_options'&gt;Run the emulator with the correct library path and options&lt;/h4&gt;

&lt;p&gt;Make sure to&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Set the library path to the directory containing the Open GL library for the emulator (LD_LIBRARY_PATH=&amp;#8230;)&lt;/li&gt;

&lt;li&gt;Run the x86 version of the emulator (run &lt;code&gt;&amp;lt;android-sdk&amp;gt;/tools/emulator-x86&lt;/code&gt;)&lt;/li&gt;

&lt;li&gt;Enable GPU use (Use the option &amp;#8220;-gpu on&amp;#8221;)&lt;/li&gt;

&lt;li&gt;Also, you need to specify the name of the Android Virtual Device to use (Use the option &lt;code&gt;-avd &amp;lt;android virtual device name&amp;gt;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On OS X the command line looks like this&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
LD_LIBRARY_PATH=~/bin/android-sdk/tools/lib ~/bin/android-sdk/tools/emulator-x86 -verbose -avd android17x86 -gpu on
&lt;/code&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>深入学习滚动视图</title>
   <link href="http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/08/13/Understanding-Scroll-Views"/>
   <updated>2013-08-13T00:00:00+08:00</updated>
   <id>http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/08/13/Understanding-Scroll-Views</id>
   <content type="html">&lt;p&gt;写在前面：这一系列文章来自&lt;a href='http://www.objc.io/'&gt;objc.io&lt;/a&gt; &lt;a href='http://www.objc.io/issue-3/scroll-view.html'&gt;Understanding Scroll Views&lt;/a&gt;。作者：&lt;a href='http://stablekernel.com/'&gt;Joe Conway&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;翻译的目的是为了自己加深理解，水平有限，欢迎指正。(左侧是原文，右侧是译文)&lt;/p&gt;
&lt;hr /&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;It may be hard to believe, but a UIScrollView isn’t much different than a standard UIView. Sure, the scroll view has a few more methods, but those methods are really just facades of existing UIView properties. Thus, most of the understanding of how a UIScrollView works comes from understanding UIView - specifically, the details of the two-step view rendering process.&lt;/td&gt;&lt;td style='text-align: left;'&gt;令人难以置信，&lt;strong&gt;&lt;a href='http://developer.apple.com/library/ios/#documentation/uikit/reference/UIScrollView_Class/Reference/UIScrollView.html'&gt;UIScrollView&lt;/a&gt;&lt;/strong&gt;并不比&lt;strong&gt;&lt;a href='http://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIView_Class/'&gt;UIView&lt;/a&gt;&lt;/strong&gt;复杂多少。当然，滚动视图的确多了一些方法，但那些方法不过是对&lt;strong&gt;UIView&lt;/strong&gt;类已有属性进行的包装。因此，对&lt;strong&gt;UIScrollView&lt;/strong&gt;运行原理的理解要从对&lt;strong&gt;UIView&lt;/strong&gt;的剖析开始，尤其是，两步法视图渲染处理的细节。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;!--more--&gt;
&lt;h2 id='rasterization__composition'&gt;Rasterization &amp;amp; Composition&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;The first part of the rendering process is known as rasterization. Rasterization simply means to take a set of drawing instructions and produce an image. UIButtons, for example, draw an image with a rounded rectangle and a title in the center. These images aren’t drawn to the screen; instead, they are held onto by their view to be used during the next step.&lt;/td&gt;&lt;td style='text-align: left;'&gt;渲染处理的第一步就是&lt;strong&gt;&lt;em&gt;光栅化（rasterization）&lt;/em&gt;&lt;/strong&gt;。光栅化简单来说就是执行一系列绘制指令，生成一副图像（image）。举个栗子，&lt;strong&gt;UIButton&lt;/strong&gt;就是绘制一个标题居中显示的圆角矩形的图像。这些图像并不直接绘制到屏幕上，而是被它们的视图所保存，用以在下一步处理中使用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Once each view has its rasterized image, these images are drawn on top of each other to produce one screen-sized image in a step called composition. The view hierarchy plays a big role in how composition occurs: a view’s image is composited on top of its superview’s image. Then, that composited image is composited on top of the super-superview’s image, and so on. The view at the top of the hierarchy is the window and its composited image (which is a composite of every image in the view hierarchy) is what the user sees.&lt;/td&gt;&lt;td style='text-align: left;'&gt;一旦每个视图都有了自己的栅格化图像，这些图像就会被绘制到其他视图的顶层，以生成一个屏幕大小的图像，这一步被称为&lt;strong&gt;&lt;em&gt;合成(composition)&lt;/em&gt;&lt;/strong&gt;。视图的层级决定了如何来进行合成：一个视图的图像被合成到其父视图（superview）的顶层。然后，那个合成后的图像被合成到上上级父视图（super-superview）中，以此类推。处于视图顶层逻辑的是窗口（window），窗口合成的图像（也就是视图层级中每一图像所最终合成的那张图像）就是我们用户所能看到的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Conceptually, this idea of layering independent images on top of each other to produce a final, flat image should make sense, especially if you have used a tool like Photoshop before. We also have another article in this issue explaining in detail how pixels get onto the screen.&lt;/td&gt;&lt;td style='text-align: left;'&gt;理论上讲，这种分层绘制生成最终平面的思想不难理解，尤其是如果你以前使用过类似Phtotshop等工具的话。我们的另一篇文章&lt;a href='http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html'&gt;how pixels get onto the screen&lt;/a&gt;对这个问题有更深入的分析。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Now, recall that every view has a bounds and frame rectangle. When laying out an interface, we deal with the frame rectangle of a view. This allows us to position and size the view. The frame and bounds of a view will always have the same size, but their origin will differ. Understanding how these two rectangles work is the key to understanding how UIScrollView works.&lt;/td&gt;&lt;td style='text-align: left;'&gt;现在，回到这个话题上来：每个视图都有&lt;a href='http://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instp/UIView/bounds'&gt;bounds&lt;/a&gt;和&lt;a href='http://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instp/UIView/frame'&gt;frame&lt;/a&gt;两个矩形。在布局界面时，我们用到的是视图的&lt;strong&gt;frame&lt;/strong&gt;属性，这个参数能用来规定视图的位置和大小。视图的&lt;strong&gt;frame&lt;/strong&gt;和&lt;strong&gt;bounds&lt;/strong&gt;应该总是保持大小一致，但它们的原点（origin）是不同的。理解了这两个矩形的原理就理解了&lt;strong&gt;UIScrollView&lt;/strong&gt;的原理。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;During the rasterization step, a view doesn’t care about what is going to happen in the upcoming composition step. That is to say, it doesn’t care about its frame (which will be used to position the view’s image) or its place in the view hierarchy (which will determine the order in which it is composited). The only thing a view cares about at this time is drawing its own content. This drawing occurs in each view’s drawRect: method.&lt;/td&gt;&lt;td style='text-align: left;'&gt;在光栅化那步中，视图并不关心在接下来的合成中会发生什么事情。也就是说，视图并不关心在视图层级(视图层级决定了合成的顺序)中它的&lt;strong&gt;frame&lt;/strong&gt;(被用来规定视图图像的位置)，或者它被放在哪里。在这一步中，视图所唯一关心的是绘制它的内容。这个绘制发生在每个视图的&lt;a href='http://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instm/UIView/drawRect:'&gt;&lt;code&gt;drawRect:&lt;/code&gt;&lt;/a&gt;方法中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Before drawRect: is called, a blank image is created for the view to draw its content in. This image’s coordinate system is the bounds rectangle of the view. For nearly every view, the bounds rectangle’s origin is {0, 0}. Thus, to draw something in the top-left corner of the rasterized image, you would draw at the origin of the bounds, the point {x:0, y:0}. To draw something in the bottom right corner of an image, you would draw at point {x:width, y:height}. If you draw outside of a view’s bounds, that drawing is not part of the rasterized image and is discarded.&lt;/td&gt;&lt;td style='text-align: left;'&gt;在&lt;code&gt;drawRect:&lt;/code&gt;被调用之前，视图会创建一个空白的图像用于绘制内容。这个空白图像的坐标系就是视图的&lt;strong&gt;bounds&lt;/strong&gt;。几乎每一个视图，&lt;strong&gt;bounds&lt;/strong&gt;矩形的原点都是&lt;code&gt;{0，0}&lt;/code&gt;。因此，为了在栅格化图像的左上角绘制内容，你要在&lt;strong&gt;bounds&lt;/strong&gt;的原点进行绘制，该点的值为&lt;code&gt;{x:0,y:0}&lt;/code&gt;。要想在栅格化图像的右下角绘制内容，你的绘制点要设置为&lt;code&gt;{x:width,y:height}&lt;/code&gt;。如果你在一个视图的&lt;strong&gt;bounds&lt;/strong&gt;以外进行绘制，那么所绘制的内容不属于栅格化图像，会被丢弃不处理。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;img alt='scroll view 2' src='http://leyleo.github.io/assets/images/201308/scroll-view-2.png' /&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;During the composition step, each view composites its rasterized image on top of its superview’s image (and so on). A view’s frame rectangle determines where the view’s image is drawn on its superview’s image - the origin of the frame indicates the offset between the top-left corner of the view’s image and its superview’s image. So, a frame origin of {x:20, y:15} will create a composited image where the view’s image is drawn on top of its superview’s image, shifted to the right 20 points and down 15 points. Because the frame and bounds rectangle of a view are always the same size, the image is composited pixel for pixel to its superview’s image. This ensures there is no stretching or shrinking of the rasterized image.&lt;/td&gt;&lt;td style='text-align: left;'&gt;在合成那步中，每个视图将自身的栅格化图像合成到父视图图像的顶层。一个视图的&lt;strong&gt;frame&lt;/strong&gt;矩形决定了自身图像会被绘制到父视图图像的哪里——&lt;strong&gt;frame&lt;/strong&gt;的&lt;strong&gt;origin&lt;/strong&gt;决定了自身图像的左上角在父视图图像中的偏移量。frame origin为&lt;code&gt;{x:20,y:15}&lt;/code&gt;意味着这个视图的图像将被合成到父视图图像上原点右偏20，下移15的位置。因为一个视图的&lt;strong&gt;frame&lt;/strong&gt;矩形和&lt;strong&gt;bounds&lt;/strong&gt;矩形大小总是一致的，所以视图的图像每一像素都被映射到父视图图像上。这保证了栅格化图像不会拉伸变形。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;img alt='scroll view 1' src='http://leyleo.github.io/assets/images/201308/scroll-view-1.png' /&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Remember, we’re talking about just one composite operation between a view and its superview. Once those two views are composited together, the resulting composite image is composited with the super-superview’s image and so on: a snowball effect.&lt;/td&gt;&lt;td style='text-align: left;'&gt;要注意，我们现在讨论的只是一个视图和它父视图间的一种合成操作。一旦两个视图被合成到一起，所得到的合成图像将被上上个视图的图像组合在一起，以此类推，这像滚雪球一样。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Think about the math behind compositing an image onto another. The top-left corner of a view’s image is offset by its frame’s origin and then drawn onto its superview’s image:&lt;/td&gt;&lt;td style='text-align: left;'&gt;思考下一个图像合成到另一个图像上的数学算法。一个视图的图像左上角加上自身&lt;strong&gt;frame&lt;/strong&gt;的原点偏移量，然后被绘制在父视图的图像上：&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;CompositedPosition.x = View.frame.origin.x - Superview.bounds.origin.x;
CompositedPosition.y = View.frame.origin.y - Superview.bounds.origin.y;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, as we have said before, the origin of a view’s bounds rectangle is typically just {0, 0}. Thus, when doing the math, we just drop out one of the values and we get:&lt;/p&gt;

&lt;p&gt;如上所述，视图的&lt;strong&gt;bounds&lt;/strong&gt;矩形的原点显然是&lt;code&gt;{0,0}&lt;/code&gt;。因此，在进行数学运算时，我们去掉这一项的值，于是得到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CompositedPosition.x = View.frame.origin.x;
CompositedPosition.y = View.frame.origin.y;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, we can look at a few different frames and see how they would look:&lt;/p&gt;

&lt;p&gt;我们来看几种不通的&lt;strong&gt;frame&lt;/strong&gt;，看效果如何：&lt;/p&gt;

&lt;p&gt;&lt;img alt='scroll view 3' src='http://leyleo.github.io/assets/images/201308/scroll-view-3.png' /&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;And this should make sense. We change the frame’s origin of the button, and it changes its position relative to its lovely purple superview. Notice that if we move the button so that parts of it are outside of the bounds of the purple superview, those parts are clipped in the same way drawing during rasterization would be clipped. However, technically, because of how iOS handles compositing under the hood, you can have a subview render outside of its superview’s bounds, but drawing during rasterization cannot occur outside of a view’s bounds.&lt;/td&gt;&lt;td style='text-align: left;'&gt;应该很好理解。我们改变按钮&lt;strong&gt;frame&lt;/strong&gt;的原点，它在粉色父视图上的位置就跟着变了。注意，当我们将按钮移到部分在粉色父视图外面时，那部分就随着光栅化所绘制图像的裁剪而被裁剪掉了。不过，从技术上将，根据iOS处理合成的底层原理，你可以让一个子视图渲染父视图&lt;strong&gt;bounds&lt;/strong&gt;以外的图像，不过在视图&lt;strong&gt;bounds&lt;/strong&gt;以外的部分不会存在光栅化处理中的绘制行为。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id='scroll_views_content_offset'&gt;Scroll View&amp;#8217;s Content Offset&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Now, what does all of this have to do with UIScrollView? Everything. Think about a way we could accomplish scrolling: we could have a view whose frame we change when we drag it. It accomplishes the same thing, right? If I drag my finger to the right, I increase the origin.x of the view I’m dragging and voila, scroll view!&lt;/td&gt;&lt;td style='text-align: left;'&gt;讲了这么多，跟&lt;strong&gt;UIScrollView&lt;/strong&gt;有啥关系呢？万事万物皆有联系。思考一个可以实现滚动的方案：我们能做一个拖拽它就能改变它frame的视图。这不就结啦？如果我向右拖拽视图，我就增大它的&lt;code&gt;origin.x&lt;/code&gt;，看，滚动视图成了。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;The problem with that, of course, is that there are typically many views in a scroll view. To implement this panning feature, you would have to change the frames of every view every time the user moved his or her finger. But we’re missing something. Remember that equation that we came up with to determine where a view composited its image onto its superview?&lt;/td&gt;&lt;td style='text-align: left;'&gt;当然，那个方案有个问题，就是一个滚动视图中会有很多个视图。为了扩展这个功能，你不得不在用户每次移动他/她的手指时，改变每一个视图的&lt;strong&gt;frame&lt;/strong&gt;。我们好像忘了什么事情。记得么，我们得出来的，用来计算一个视图会把自身的图像合成到父视图图像哪里的那个公式：&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;CompositedPosition.x = View.frame.origin.x - Superview.bounds.origin.x;
CompositedPosition.y = View.frame.origin.y - Superview.bounds.origin.y;&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;We dropped the Superview.bounds.origin values because they were always 0. But what if they weren’t? What if, say, we used the same frames from the previous diagram, but we changed the purple view’s bounds origin to something like {-30, -30}. We’d get this:&lt;/td&gt;&lt;td style='text-align: left;'&gt;我们消掉了&lt;code&gt;Superview.bounds.origin&lt;/code&gt; 那项，因为它总是为0，但如果它不为0呢？也就是说，如果我们还用上面那张图为例，只不过将粉色视图的&lt;strong&gt;bounds&lt;/strong&gt;原点变成其他的，譬如&lt;code&gt;{-30,-30}&lt;/code&gt;，我们这下得到：&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;img alt='scroll view 4' src='http://leyleo.github.io/assets/images/201308/scroll-view-4.png' /&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Now, the beauty of this is that every single subview of this purple view is shifted by the change to its bounds. This is, in fact, exactly how a scroll view works when you set its contentOffset property: it changes the origin of the scroll view’s bounds. In fact, contentOffset isn’t even real! Its code probably looks like this:&lt;/td&gt;&lt;td style='text-align: left;'&gt;神奇的事情发生了：仅仅改变了粉色视图的&lt;strong&gt;bounds&lt;/strong&gt;值，它的每个子视图却都发生了移动。实际上，这就是当你设置了滚动视图的&lt;code&gt;contentOffset&lt;/code&gt;值时，滚动视图的移动原理：它改变的是滚动视图&lt;strong&gt;bounds&lt;/strong&gt;的原点。实际上&lt;code&gt;contentOffset&lt;/code&gt;根本不存在，它的代码大概如下：&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;- (void)setContentOffset:(CGPoint)offset
{
	CGRect bounds = [self bounds];
	bounds.origin = offset;
	[self setBounds:bounds];
}&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Notice that in the previous diagram, changing the bounds’ origin enough moved the button outside of the composited image produced by the purple view and the button. This is just what happens when you scroll a scroll view enough so that a view disappears!&lt;/td&gt;&lt;td style='text-align: left;'&gt;上图中需要注意一点，将粉色视图的&lt;strong&gt;bounds&lt;/strong&gt;原点改变足够大，就能将按钮移出粉色视图和按钮所要合成的图像之外。这就是为什么你滚动一个scroll view足够多，上面的一个视图就会消失不见。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id='a_window_into_the_world_content_size'&gt;A Window into the World: Content Size&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Now that the hard part is out of the way, let’s look at another property of UIScrollView, contentSize.&lt;/td&gt;&lt;td style='text-align: left;'&gt;最难的部分已经讲完了，现在我们来看&lt;strong&gt;UIScrollView&lt;/strong&gt;的另一个属性，&lt;strong&gt;&lt;a href='http://developer.apple.com/library/ios/documentation/uikit/reference/UIScrollView_Class/Reference/UIScrollView.html#//apple_ref/occ/instp/UIScrollView/contentSize'&gt;contentSize&lt;/a&gt;&lt;/strong&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;The content size of a scroll view doesn’t change anything about the bounds of a scroll view and therefore does not impact how a scroll view composites its subviews. Instead, the content size defines the scrollable area. By default, a scroll view’s content size is a big, fat {w:0, h:0}. Since there is no scrollable area, the user can’t scroll, but the scroll view will still display all of the subviews that fit inside the scroll view’s bounds.&lt;/td&gt;&lt;td style='text-align: left;'&gt;一个滚动视图的内容尺寸（content size）不会对视图的&lt;strong&gt;bounds&lt;/strong&gt;产生任何影响，因此也不会影响视图对其子视图的合成。content size定义了滚动视图的可移动区域(scrollable area)。默认情况下，滚动视图的content size是&lt;code&gt;{w:0,h:0}&lt;/code&gt;，也就是没有可移动区域，用户无法滚动视图，不过滚动视图会显示&lt;strong&gt;bounds&lt;/strong&gt;内所有子视图内容。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;When the content size is set to be larger than the bounds of the scroll view, the user is allowed to scroll. You can think of the bounds of a scroll view as a window into the scrollable area defined by the content size:&lt;/td&gt;&lt;td style='text-align: left;'&gt;当滚动视图的content size设置为比&lt;strong&gt;bounds&lt;/strong&gt;大的区域时，用户就能滚动视图了。你可以看作是通过滚动视图的&lt;strong&gt;bounds&lt;/strong&gt;大小的窗口去操作由content size设定的可滚动区域：&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;img alt='scroll view 5' src='http://leyleo.github.io/assets/images/201308/scroll-view-5.png' /&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;When the content offset is {x:0, y:0}, the viewing window’s top-left corner is in the top-left corner of the scrollable area. This is also the minimum value of the content offset; the user can’t scroll to the left or above the scrollable area. There’s nothing there!&lt;/td&gt;&lt;td style='text-align: left;'&gt;当内容偏移量(content offset)为&lt;code&gt;{x:0,y:0}&lt;/code&gt;时，视图窗口的左上角在可移动区域的左上角，这也是内容偏移量的最小值；用户无法再向左或者向上移动视图了，那什么也没有了。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;The maximum value for the content offset is the difference between the content size and the scroll view’s bounds’ size. This makes sense; scrolling all the way to the bottom right, the user is stopped so that the bottom-right edge of the scrolling area is flush with the bottom-right edge of the scroll view’s bounds. You could write the maximum content offset like this:&lt;/td&gt;&lt;td style='text-align: left;'&gt;内容偏移量的最大值是content size和滚动视图的&lt;strong&gt;bounds&lt;/strong&gt; size的差值。这很好理解，将视图一直滚动到右下角，直至滚动区域的右下角边界与滚动视图&lt;strong&gt;bounds&lt;/strong&gt;的右下角边界齐平。如下可得出最大偏移量：&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;contentOffset.x = contentSize.width - bounds.size.width;
contentOffset.y = contentSize.height - bounds.size.height;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='tweaking_the_window_with_content_insets'&gt;Tweaking the Window with Content Insets&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;The property &lt;a href='http://developer.apple.com/library/ios/documentation/uikit/reference/UIScrollView_Class/Reference/UIScrollView.html#//apple_ref/occ/instp/UIScrollView/contentInset'&gt;contentInset&lt;/a&gt; can change the maximum and minimum values of the content offset to allow scrolling outside of the scrollable area. Its type is &lt;a href='http://developer.apple.com/library/ios/#documentation/uikit/reference/UIKitDataTypesReference/Reference/reference.html#//apple_ref/doc/c_ref/UIEdgeInsets'&gt;UIEdgeInsets&lt;/a&gt;, which consists of 4 numbers: {top, left, bottom, right}. When you introduce an inset, you change the range of the content offset. For example, setting the content inset to have a value of 10 for its top value allows the content offset’s y value to reach -10. This introduces padding around the scrollable area.&lt;/td&gt;&lt;td style='text-align: left;'&gt;属性值&lt;strong&gt;&lt;a href='http://developer.apple.com/library/ios/documentation/uikit/reference/UIScrollView_Class/Reference/UIScrollView.html#//apple_ref/occ/instp/UIScrollView/contentInset'&gt;contentInset&lt;/a&gt;&lt;/strong&gt;能改变滚动视图可移动区域的最大和最小内容偏移量，以便用户能移动到可移动区域之外。这个属性是&lt;strong&gt;&lt;a href='http://developer.apple.com/library/ios/#documentation/uikit/reference/UIKitDataTypesReference/Reference/reference.html#//apple_ref/doc/c_ref/UIEdgeInsets'&gt;UIEdgeInsets&lt;/a&gt;&lt;/strong&gt;类型的，有四个数值：&lt;code&gt;{top, left, bottom ,right}&lt;/code&gt;。 使用content inset就能改变内容偏移量的范围。例如，将content inset的 top 值设置为10， 那么content offset的 y 值最小能到-10. 也就是在可移动区域周围设置了内边距（padding）值。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;img alt='scroll view 6' src='http://leyleo.github.io/assets/images/201308/scroll-view-6.png' /&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;This may not seem very useful at first. In fact, why not just increase the content size? Well, you should avoid changing the content size of a scroll view unless you have to. To understand why, consider a table view (UITableView is a subclass of UIScrollView, so it has all of the same properties). The table view’s scrollable area has been carefully calculated to fit each one of its cells snugly. When you scroll past the boundaries of the table view’s first or last cells, the table view snaps the content offset back into place, so that the cells once again fit snugly in the scroll view’s bounds.&lt;/td&gt;&lt;td style='text-align: left;'&gt;一眼看上去这个值没啥用处。事实上，为什么不直接加大content size呢？是这样的，不到万不得已，你最好避免改变滚动视图的content size。想知道为什么嘛？思考一下列表视图（table view）( &lt;strong&gt;UITableView&lt;/strong&gt; 是 &lt;strong&gt;UIScrollView&lt;/strong&gt; 的子类，它有上述所有的参数)吧。为了让列表视图的每一个cell都显示正常，列表视图的可移动区域需要经过精心的计算。当你将列表视图拉到第一个cell上面，或者最后一个cell下面时，视图会回弹，使得cells最终能在滚动视图的边界内正常显示。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Now, what happens when you want to implement pull to refresh using a UIRefreshControl? You can’t put the UIRefreshControl within the scrollable area of the table view, otherwise, the table view would allow the user to stop scrolling halfway through the refresh control, and the top would snap to the top of the refresh control. Thus, you must put refresh control just above the scrollable area. This allows the content offset to snap back to the first row, not the refresh control.&lt;/td&gt;&lt;td style='text-align: left;'&gt;如果你想用 &lt;strong&gt;&lt;a href='http://developer.apple.com/library/ios/#documentation/uikit/reference/UIRefreshControl_class/Reference/Reference.html'&gt;UIRefreshControl&lt;/a&gt;&lt;/strong&gt; 实现下拉刷新会怎样？你不能将 &lt;strong&gt;UIRefreshControl&lt;/strong&gt; 放到列表视图的可移动区域内，否则列表视图会因为刷新操作让用户的滚动操作半路失效，而且顶部与刷新控件的顶端齐平。因此，你必须将刷新控件放到可移动区域的上面，这样才能保证content offset偏移后能够回弹到列表的第一行，而不是跑到刷新控件那。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;But wait, if you initiate the pull-to-refresh mechanism by scrolling far enough, the table view does allow the content offset to snap refresh control into the scrollable area, and this is because of the table view’s content inset. When the refresh action is initiated, the content inset is adjusted so that the minimum content offset includes the entirety of the refresh control. When the refresh completes, the content inset is returned to normalcy, the content offset follows suit, and none of the math required for determining the content size needs to be re-computed.&lt;/td&gt;&lt;td style='text-align: left;'&gt;不过，如果你滚动到触发了下拉刷新，列表视图就会偏移到可移动区域上刷新控件的位置，这个偏移操作倚赖于content inset值。当刷新事件被触发，content inset值就会被调整到能包含整个刷新控件的最小值。当刷新完成，content inset值会被复原，content offset也会跟着改变，而且不需要重新计算content size等。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;How can you use the content inset in your own code? Well, there is one great use for the it: when the keyboard is on the screen. Typically, you try to design a user interface that fits the screen snugly. When the keyboard appears on the screen, you lose a few hundred pixels of that space. All of the stuff underneath the keyboard is obscured.&lt;/td&gt;&lt;td style='text-align: left;'&gt;那么，怎么在你自己的代码中使用content inset呢？有一个场景非常有用：屏幕中出现键盘的时候。尤其是你想让用户界面看起来很贴合屏幕大小时。当键盘出现在屏幕上时，你本来视图的可见区域就少了很多，所有键盘下的内容被遮挡不可见了。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Now, the scroll view’s bounds haven’t changed, and neither has its content size (nor should it). But the user can’t scroll the scroll view. Think about the equation from earlier: the maximum content offset is the difference between the content size and the bounds’ size. If they are equal, which they are in your snug interface that now has a keyboard messing up your day, the maximum content offset is {x:0, y:0}.&lt;/td&gt;&lt;td style='text-align: left;'&gt;现在滚动视图的&lt;strong&gt;bounds&lt;/strong&gt;并没有改变，它的content size也没有变化。但是用户却不能滚动这个视图。回想一下前面讲到的公式：内容偏移量的最大值是content size和滚动视图的bounds size的差值。如果在键盘出现前后的界面中content size和 bounds 值都是一致的，那么content offset最大值就是&lt;code&gt;{x:0, y:0}&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;The trick, then, is to put the interface in a scroll view. The content size of the scroll view remains fixed at the same size as the scroll view’s bounds. When the keyboard appears on the screen, you set the bottom of the content inset equal to the height of the keyboard.&lt;/td&gt;&lt;td style='text-align: left;'&gt;解决方法就是将界面放到一个滚动视图中去。这个滚动视图的content size仍然是跟bounds大小一致。当键盘被唤起时，将content inset的bottom值设置为键盘高度。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;img alt='scroll view 7' src='http://leyleo.github.io/assets/images/201308/scroll-view-7.png' /&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;This allows the maximum value of the content offset to show the area beyond the scrollable area. The top of the visible area is outside the bounds of the scroll view, and is therefore clipped (although it is also off the screen itself, so that doesn’t matter too much).&lt;/td&gt;&lt;td style='text-align: left;'&gt;这个值决定了视图滚动到可移动区域外的content offset的最大值。可视区域的顶部在滚动视图的边界之外因而被裁剪不见（它已经不在屏幕内，无关紧要了）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Hopefully, this gives you some insight into the inner workings of scroll views. Are you wondering about zooming? Well, we won’t talk about it today, but here’s a fun tip: check the transform property of the view you return from viewForZoomingInScrollView:. Once again, you’ll find that a scroll view is just cleverly using already-existing properties of UIView.&lt;/td&gt;&lt;td style='text-align: left;'&gt;希望本文能为你理解滚动视图的内在原理带来帮助。你想了解缩放（zooming）相关的内容嘛？我们今天不讨论那个话题，不过奉送个有趣的小贴士：判断 &lt;code&gt;viewForZoomingInScrollView:&lt;/code&gt; 返回值view的 &lt;strong&gt;transform&lt;/strong&gt; 属性值。你会再次发现滚动视图(scroll view)不过是非常聪明地使用了&lt;strong&gt;UIView&lt;/strong&gt;已有的属性。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr /&gt;
&lt;p&gt;本话题更多文章请见：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/08/10/views/'&gt;Editorial 导论&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html'&gt;Getting Pixels onto the Screen&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-3/collection-view-layouts.html'&gt;Custom Collection View Layouts&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-3/custom-controls.html'&gt;Custom Controls&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-3/advanced-auto-layout-toolbox.html'&gt;Advanced Auto Layout Toolbox&lt;/a&gt; 待译&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>Views</title>
   <link href="http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/08/10/views"/>
   <updated>2013-08-10T00:00:00+08:00</updated>
   <id>http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/08/10/views</id>
   <content type="html">&lt;p&gt;写在前面：这一系列文章来自&lt;a href='http://www.objc.io/'&gt;objc.io&lt;/a&gt; &lt;a href='http://www.objc.io/issue-3/editorial.html'&gt;issue-3&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;翻译的目的是为了自己加深理解，水平有限，欢迎指正。(左侧是原文，右侧是译文)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href='http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/08/10/views/'&gt;(1) This time&lt;/a&gt; we will explore several aspects of the view layer. Daniel starts with the basics of &lt;a href=''&gt;(2) how pixels actually get onto the screen&lt;/a&gt;, and Joe explains some &lt;a href='http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/08/13/Understanding-Scroll-Views/'&gt;(3) internals of scroll views&lt;/a&gt;. On the more practical side, Ole shows you how to create completely &lt;a href=''&gt;(4) custom collection view layouts&lt;/a&gt;, while Chris talks about &lt;a href=''&gt;(5) creating custom controls&lt;/a&gt;. Finally, Florian looks beyond the basics of Auto Layout in his &lt;a href=''&gt;(6) advanced Auto Layout toolbox&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id='id1'&gt;导论&lt;/h2&gt;

&lt;p&gt;August 2013&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Source&lt;/th&gt;&lt;th&gt;译文&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Welcome to objc.io issue #3!&lt;/td&gt;&lt;td style='text-align: left;'&gt;欢迎来到objc.io话题三！&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;This issue is all about the view layer. Of course the view layer has so many aspects that we had to narrow it down to a few topics – which are hopefully of interest to many developers – while leaving tons of other interesting stuff aside (perhaps to be addressed in a later issue?).&lt;/td&gt;&lt;td style='text-align: left;'&gt;这次的话题是关于视图层（view layer）的。当然了，由于视图层包含内容太多，我们不得不只选择其中几个方面的内容，放了很多想听其他关于视图层的开发者童鞋鸽子（要不放到以后的话题中去讲？）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;First, we cover some internals of how pixels actually get drawn onto the screen. Aside from it simply being fascinating to take a sneak peak at the full stack under the covers of the frameworks we use everyday, it will help application developers to make smart choices when it comes to graphic performance. Similarly, Joe Conway – author of the Big Nerd Ranch’s iOS Programming Guide – takes a closer look at how scroll views take advantage of UIView’s architecture to get their work done.&lt;/td&gt;&lt;td style='text-align: left;'&gt;首先，我们对像素点到底是怎么绘制到屏幕上的问题一探究竟。之外，由浅入深地揭露我们常用框架背后的所有故事，了解这些有助于应用开发者在改善图形性能时选择正确的决策。与此同时，&lt;a href='http://www.bignerdranch.com/book/ios_programming_the_big_nerd_ranch_guide_rd_edition_'&gt;Big Nerd Ranch&amp;#8217;s iOS Programming Guide&lt;/a&gt;的作者&lt;a href='http://stablekernel.com/'&gt;Joe Conway&lt;/a&gt;带咱们近距离认识scroll视图是如何利用&lt;strong&gt;UIView&lt;/strong&gt;的结构去实现的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Balancing these topics of internals, we then dive into a series of very practical view layer details: creating custom collection view layouts (many thanks to Ole Begemann!), creating custom controls, and advanced Auto Layout tips and tricks.&lt;/td&gt;&lt;td style='text-align: left;'&gt;在一窥内幕之余，我们分享了一系列关于视图层非常实用的细节：创建自定义collection视图布局（非常感谢&lt;a href='http://oleb.net/'&gt;Ole Begemann&lt;/a&gt;）,创建自定义控制器，及关于高级自动布局的tips和常见的坑。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;As always, we are happy to hear from you with feedback, suggestions for future topics, or if you would like to contribute an article to objc.io yourself (you don’t need to be a native speaker, thanks to our copy editor Natalye).&lt;/td&gt;&lt;td style='text-align: left;'&gt;我们一如既往地期待着你的反馈，或者关于未来讨论话题的建议，如有兴趣欢迎投稿（语种不限，感谢我们的审编&lt;a href='https://twitter.com/deutschbitte'&gt;Natalye&lt;/a&gt;）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;We wish you happy reading from a very summery Berlin，&lt;/td&gt;&lt;td style='text-align: left;'&gt;We wish you happy reading from a very summery Berlin，&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style='text-align: left;'&gt;Chris, Daniel, and Florian&lt;/td&gt;&lt;td style='text-align: left;'&gt;Chris, Daniel, and Florian&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr /&gt;
&lt;p&gt;本话题更多文章请见：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html'&gt;Getting Pixels onto the Screen&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://leyleo.github.io/%E6%8A%80%E6%9C%AF/2013/08/13/Understanding-Scroll-Views/'&gt;Understanding Scroll Views 深入学习滚动视图&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-3/collection-view-layouts.html'&gt;Custom Collection View Layouts&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-3/custom-controls.html'&gt;Custom Controls&lt;/a&gt; 待译&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.objc.io/issue-3/advanced-auto-layout-toolbox.html'&gt;Advanced Auto Layout Toolbox&lt;/a&gt; 待译&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>写在最前</title>
   <link href="http://leyleo.github.io/%E7%A2%8E%E7%A2%8E%E5%BF%B5/2012/09/05/at-the-beginning"/>
   <updated>2012-09-05T00:00:00+08:00</updated>
   <id>http://leyleo.github.io/%E7%A2%8E%E7%A2%8E%E5%BF%B5/2012/09/05/at-the-beginning</id>
   <content type="html">&lt;p&gt;又开始写笔记了。&lt;/p&gt;

&lt;p&gt;源自于想记录下光怪陆离又气势磅礴的梦境，无奈有科幻的梦靥却无作家的文笔，只有程序媛刨根揪底的思维习气，就再一次地鼓捣起自己的博客，记录些什么。&lt;/p&gt;

&lt;p&gt;幸好，将这个世界当做一场梦来碎碎念，也不失为一种乐趣。&lt;/p&gt;</content>
 </entry>
 
 
</feed>